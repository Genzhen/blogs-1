* 1、函数参数的默认值

  ```
  // 写法一
  if (typeof y === 'undefined') {
    y = 'World';
  }
  // 写法二
  if (arguments.length === 1) {
    y = 'World';
  }
  // 写法三(缺点不能赋值false)
  y = y || 'World';
  ```

  ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值
  的参数。这是因为有了默认值以后，该参数可以省略，只有位于尾部，才可能判断出到底省略了哪些参数。  
  如果传入undefined，将触发该参数等于默认值，null则没有这个效果。指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。  
  也就是说，  指定了默认值后，length属性将失真。(function(a, b, c = 5){}).length // 2  
  参数变量是默认声明的，所以不能用let或const再次声明。  

* 2、rest参数  

  ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。  
  rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。函数的length属性，不包括rest参数。  
  rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。  

* 3、扩展运算符  

  扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。  
  如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。  
  何类似数组的对象，都可以用扩展运算符转为真正的数组。  

* 4、箭头函数  

  ES6允许使用“箭头”（=>）定义函数。var f = v => v;  等于 var f = function(v) {return v;};  
  如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。  
  如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。  
  ```
  var sum = (num1, num2) => { return num1 + num2; }  
  ```
  由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。  

  箭头函数有几个使用注意点：  
  - （1）.函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。
  - （2）.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  - （3）.不可以使用arguments对象，该对象在函数体内不存在。

* 5、函数绑定  

  函数绑定运算符是并排的两个双引号（::），双引号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（   即this对象），绑定到右边的函数上面。  
  ```
  foo::bar(...arguments);
  i// 等同于
  bar.apply(foo, arguments);
  ```

* 6、尾调用  

  尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。  
  尾调用不一定出现在函数尾部，只要是最后一步操作即可。  

  我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部
  调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还
  调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。  

  尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用
  内层函数的调用帧，取代外层函数的调用帧就可以了。  

* 7、尾递归  

  函数调用自身，称为递归。如果尾调用自身，就称为尾递归。  
  递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只
  存在一个调用帧，所以永远不会发生“栈溢出”错误。  

  ```
  function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }
  ```

* 8、柯里化  

  函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。  
  ```
  function currying(fn, n) {
    return function (m) {
      return fn.call(this, m, n);
    };
  }
  const factorial = currying(tailFactorial, 1);
  factorial(5) // 120
  ```
  递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现。
