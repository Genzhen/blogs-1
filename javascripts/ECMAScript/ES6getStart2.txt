字符串的扩展
1、codePointAt()
  JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符(Unicode码点大于0xFFFF的字符)，
  JavaScript会认为它们是两个字符。
  ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。codePointAt方法是测试一个字符由两个字节还是
  由四个字节组成的最简单方法。
  function is32Bit(c) {
      return c.codePointAt(0) > 0xFFFF;
  }
  is32Bit("𠮷") // true
  
2、String.fromCodePoint()
  ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别辅助平面的字符（编号大于0xFFFF）。
  注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。
  
3、at()
  ES5提供String.prototype.charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。
  ES7提供了at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。
  
4、字符的Unicode表示法
  JavaScript允许采用“\uxxxx”形式表示一个字符，其中“xxxx”表示字符的码点。这种表示法只限于\u0000——\uFFFF之间的字符。超出
  这个范围的字符，必须用两个双字节的形式表达。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
  
5、正则表达式的修饰符
  修饰符u
  用来正确处理大于\uFFFF的Unicode字符。
  点（.）字符在正则表达式中，对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。\S预定义模式也一样。
  
  y修饰符
  y修饰符，叫做“粘连”（sticky）修饰符。它的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始，
  不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始。
  
6、includes(), startsWith(), endsWith()
  includes()：返回布尔值，表示是否找到了参数字符串。
  startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
  endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
  上面方法表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从
  第n个位置直到字符串结束。
  
7、repeat()
  repeat()返回一个新字符串，表示将原字符串重复n次。
  
8、Regexp.escape()
字符串必须转义，才能作为正则模式。
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
