## 深入理解作用域（scope）

> 一段程序代码中所用到的变量或函数并不总是有效、可用的，而限定这个变量的可用性的代码范围就是作用域。Javascript中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的），但eval 和 with可以产生动态作用域的效果。

作用域是基于函数，js解释器在创建 执行上下文栈 的时候,会同时创建一个 scope chain（单向链表）。在执行上下文的执行阶段的时候, 当需要访问某个变量时, 会首先在当前的执行上下文的VO中查找。如果找不到, 就往链表的下一个位置查找，一直到最后一个位置。

* **词法作用域**

    又叫静态作用域，是指在词法分析阶段就确定了，不会改变。

* **动态作用域**

    是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。
    需要明确的是，Javascript并不具有动态作用域，它只有词法作用域，简单明了。但是，它的 eval()、with、this机制某种程度上很像动态作用域，使用上要特别注意。

* **主要区别**

    词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的（this也是！）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。通俗说法，词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，去函数定义时的环境中查询。动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用时的环境中查。

    词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，去函数定义时的环境中查询。（并非this对象）

    动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用时的环境中查。

    ![作用域案例](../images/scope.png)

* **作用域(scope) vs 执行上下文(Execution context)**

    - 执行上下文：可以理解为函数调用、代码运行时的概念，表示代码执行的变量环境(作用域链)，记录着函数在哪里调用（调用栈）、函数的调用方法、传参等信息。函数调用执行时才会产生，一个代码块(包括函数体，全局作用域)对应一个执行上下文，执行堆栈最上面的可执行上下文被称为running execution context；当顶部的被弹出，上一个挂起的上下文继续执行。

    执行上下文对象的内部属性：[[code evaluation]]、[[function]]、[[Real]]。上下文控制着this的引用，

    ```js
    // 存入堆栈顺序：global exec ctx -> outer exec ctx -> inner exec ctx

    function outer() { 
        inner();
    }
    function inner() {
        console.log('test');
    }
    outer();
    ```

    - 作用域：可以理解为代码载入时的概念，变量声明定义时就定了，代表变量标识和函数的使用范围，无法使用js获取，只存在于js引擎中，更规范的叫法词法环境。作用域由两部分组成：记录作用域内的变量信息；一个引用__outer__，指向当前作用域的父级作用域，用于向上递归查找变量。

    备注：try/catch中的catch的入参属于块级作用域，并且catch只会框住参数部分，语句主体里定义的变量并不受限，可以在外部访问。es 6的块级作用域也是类似，只框住let和const定义的变量，var定义的变量并不受限。

    - 两者关联：执行上下文不只要保持执行变量和函数信息，还会把当前的作用域以作用域链的形式保存进去。

    ```js
    |           [code]          |    [call stack]     |     [task queue]    |    [webAPI]    |
    |---------------------------|---------------------|---------------------|----------------|
    |   function outer() {      |     console.log     |                     |                |
    |      inner();             |        inner        |                     |                |
    |   }                       |        outer        |                     |                |
    |   function inner() {      |    main/anonymous   |                     |                |
    |      console.log('test'); |                     |                     |                |
    |   }                       |                     |                     |                |
    |   > outer();              |                     |                     |                |
    ```

* **避免滥用eval** 

  eval函数会将其参数当做javascript程序进行解释，并运行于调用者的局部作用域，也就是赋予了外部调用者能改变函数内部作用域的能力。尽量避免使用eval函数污染内部作用域，非用不可，尽量间接调用，再不行封装在即执行函数作用域内。  
  
  eval函数具有调用整个作用域的能力，即直接调用eval函数放在局部作用域内求值，而间接调用eval函数放在全局作用域内求值。两种间接调用方式：eval赋值给变量；`(0,eval)(parameters)`
  
  通常情况下，直接调用eval函数性能消耗较大，可能导致其包含的函数以及所有直到最外层的函数运行都相对缓慢。

* **变量声明提升（Hoisting）**

  在ES6之前，javascript是函数级作用域，而非块级作用域，也就是无法声明块级作用域的变量。实际上，变量声明看成两部分：声明、赋值。javascript会隐式地提升声明部分到函数的顶部，而赋值部分保持不动，特别提醒的是，函数的声明提升优先级更高。
  
  ```js
  var myvar = 'my value';  

  (function() {  
      alert(myvar); // undefined  
      var myvar = 'local value';  
      alert(myvar); // 'local value'
  })();
  alert(myvar); // 'my value'
  ```

## 案例分析

    ```js
    var x = 1;       
    function a() {                
        console.log(x);          // 1, 函数a创建时就确定了scope，记录x为1
    }      
    !function() {             
        var x = 2;              
        a();       
    } ();
    ```