## V8引擎优化手段

* 内联代码

  内联代码指的是把调用地址(函数被调用的那行代码)置换为被调用函数的函数体的过程。

* 隐藏类

  隐藏类工作原理和诸如 Java 语言中使用的固定对象布局(类)相似，除了它们是在运行时创建的以外。

  每当对象添加新的属性，使用转换路径来把旧的隐藏类更新为新的隐藏类。隐藏类转换是重要的，因为它们使得以同样方式创建的对象可以共享隐藏类。如果两个对象共享一个隐藏类并且两个对象添加了相同的属性，转换会保证两个对象收到相同的新的隐藏类并且所有的优化过的代码都会包含这些新的隐藏类。

* 内联缓存

  内联缓存依赖于对于同样类型的对象的同样方法的重复调用的观察。当你创建了两个同样类型的对象而使用不同的隐藏类，V8 将不可能使用内存缓存，因为即使相同类型的两个对象，他们对应的隐藏类为他们的属性分派不同的地址位移。

## V8垃圾回收

* 标记-清除算法

    + 根：一般指代码中的引用的全局变量，如js中的window，nodejs中global

  任何根变量到达不了的变量或者对象等，就可以标记为内存垃圾。算法起初会构建出一份根变量的完整列表，然后检测根变量及其后代变量是否处于激活状态，以此来标记是否是内存垃圾，整个标记阶段会中止 JavaScript 的运行。
  
  为了控制垃圾回收的成本并且使得代码执行更加稳定，V8 使用增量标记法。也就是，不遍历整个内存堆，只是遍历一部分堆，然后重启正常的代码执行。下一个垃圾回收点将会从上一个堆遍历中止的地方开始执行，这是正常的代码执行过程中有一个非常短暂的间隙。

  清除阶段由单独的线程来处理回收。 

* 引用计数(reference counting)：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，可以将这块内存释放。

  ```js
  let arr = [1, 2, 3, 4];     // arr引用了数组值，引用次数为1

  console.log('hello world');
  arr = null;         // arr解除了引用，引用次数为0，内存自动释放
  ```

  ```js
  var obj = {
      outerProp: {
          innerProp: 1
      }
  };

  // 创建两个对象，一个最外层对象，一个作为外层对象属性的内层对象。
  // obj引用外层对象，不可被回收

  var other = obj;    // 外层对象两个引用

  obj = 1;    // 外层对象只有一个引用，即变量other

  var reference = other.innerProp;
  other = undefined;  // 目前外层对象0引用，但因为外层对象的属性还有一个引用reference，因此还不能回收

  reference = null;   // 两个对象的引用都为0，现在可以回收了
  ```

## V8解析器和编译器

* 解析器  Ignition

* 编译器  TurboFan

