## 解构

> 解构允许使用模式匹配的方式进行绑定，并支持匹配 数组和对象。解构具有一定的容错机制，就像查找普通对象foo['foo']这样，当没有找到时会返回undefined（而不会直接报错）。 

* 1、数组解构赋值  

  -  ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。只要等号两边的模式相同，左边的变量就会被赋予对应的值。例如：

  ```js
  let [head, ...tail] = [1, 2, 3, 4];
  head // 1
  tail // [2, 3, 4]
  ```

  如果对undefined或null进行解构，会报错。这是因为解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。  
  
  - 解构赋值允许指定默认值。ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。解构赋值不仅适用于var命令，也适用于let和const命令。  

  - rest元素必须在最后一个元素，否则提示异常 `Uncaught SyntaxError: Rest element must be last element`

* 2、字符串的解构赋值  

  由于JavaScript引擎内部，某些场合时，字符串会被转为类似数组的对象。因此，字符串也可以解构赋值。

* 3、对象的解构赋值  

  对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。 
  
  ```js
  var { foo: baz } = { foo: "aaa", bar: "bbb" };  
  baz // "aaa"  
  ```
  
  对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。  
  
  ```js
  var {x, y = 5} = {x: 1};  
  console.log(x, y) // 1, 5  
  ```

* 4、函数参数的解构  

  函数参数的解构也可以使用默认值。  
  
  ```js
  function move({x = 0, y = 0} = {}) {
    return [x, y];
  }
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, 0]
  move({}); // [0, 0]
  move(); // [0, 0]
  ```

